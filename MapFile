import { Component, ViewChild, ElementRef, OnInit, HostBinding } from '@angular/core';


@Component({
  selector: 'nm-loadingSpinner',
  templateUrl: './loadingSpinner.html'
})
export class LoadingSpinnerComponent implements OnInit
{
    private __element: HTMLElement;
    
    constructor(private elementRef:ElementRef) 
    {
    	this.__element = elementRef.nativeElement;
    	this.hide();
    }
    
    ngOnInit() : void
    { 
		
    }
    
    show() : void
    {
		this.__showHide(true);
    }
    
    hide() : void
    {
		this.__showHide(false);
    }
    
    private __showHide(isShow:Boolean):void
    {
    	if(this.__element)
		{
			this.__element.style.display = isShow ? "block" : "none";
		} 
    }
    
}

<div class="spinner-container">
	<div class="spinner">
		<i class="fa fa-spinner fa-spin"></i>&nbsp;&nbsp;&nbsp;<b class="modal-title">Please Wait !</b>
	</div>
</div>

import {Injectable, ElementRef} from '@angular/core';
import {HttpEvent, HttpInterceptor, HttpHandler, HttpRequest, HttpResponse, HttpErrorResponse} from '@angular/common/http';

import { Observable } from 'rxjs/Observable';
import 'rxjs/add/operator/do';
import 'rxjs/add/observable/throw';
import { NMSharedService } from '../services/nmShared/nmShared.service'
import { LoadingSpinnerComponent } from '../loadingSpinner/loadingSpinner.component'
import { PopUpComponent } from '../popUpComponent/popUp.component';

@Injectable()
export class NMHttpInterceptor implements HttpInterceptor 
{
	private __activeAjaxCalls: number = 0;
	
	constructor(private sharedService: NMSharedService) 
	{
  	}
	
  	intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> 
  	{
  		this.handleCalls(true);
        //cloning Request Object to add session feature on server side when running from Angular Cli 
        let clonedReq: HttpRequest<any> = req.clone({withCredentials:true});
    	return next
    	.handle(clonedReq)
    	.do((ev: HttpEvent<any>) => {
	        if (ev instanceof HttpResponse) 
            {
	          this.handleCalls(false);
              if(ev.body && ev.body["STATUS"] && ev.body["STATUS"] === "FAILURE")
              {
                    PopUpComponent.showFailureAlertPopup(ev.body["MESSAGE"]);
                    return Observable.throw(ev.body["MESSAGE"]);
              }
	          //console.log('processing response', ev);
	        }
	    })
    	.catch(response => {
    		this.handleCalls(false);
	        if (response instanceof HttpErrorResponse) 
	        {
	          	//console.log('Processing http error', response);
	        }

       	 	return Observable.throw(response);
      	});
  	}
  	
  	private handleCalls(isRequest:Boolean):void
  	{
  		isRequest ? ++this.__activeAjaxCalls : --this.__activeAjaxCalls;
  		(this.__activeAjaxCalls == 0) ? this.sharedService.loaderElement.hide() : this.sharedService.loaderElement.show();
  	}
}


import { Injectable, ErrorHandler, Injector } from '@angular/core';
import { Router, RouteReuseStrategy, ActivatedRouteSnapshot, DetachedRouteHandle } from '@angular/router';

let hasRouterError: boolean = false;

@Injectable()
export class CustomErrorHandler implements ErrorHandler 
{
      constructor(private injector: Injector) 
      {
          
      }
      handleError(error: any) 
      {
         console.log(error); 
         if(hasRouterError) 
         {
            let router = this.injector.get(Router);
            router.navigated = false;
         }
         //throw error;
      }
}

export function CustomRouterErrorHandler(error: any) 
{
    console.log(error);
    hasRouterError = true;
    throw error;
}

export class PreventErrorRouteReuseStrategy implements RouteReuseStrategy 
{
  shouldDetach(route: ActivatedRouteSnapshot): boolean 
  { 
    return false; 
  }
  store(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void 
  {
  }
  shouldAttach(route: ActivatedRouteSnapshot): boolean 
  { 
    return false; 
  }
  retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle|null 
  { 
    return null; 
  }
  shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean 
  {
    if(hasRouterError) 
    {
      hasRouterError = false;
      return false;
    }
    return future.routeConfig === curr.routeConfig;
  }
}


