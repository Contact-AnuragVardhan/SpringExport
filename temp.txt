import os
import json
import traceback

from dotenv import load_dotenv
from sqlalchemy import create_engine
from langchain.sql_database import SQLDatabase
from langchain.agents import Tool

# Chinou imports (adjust to your package structure if needed)
from chinou.client.domain import LLMDescriptor
from chinou.client.proxy import ProxyLLM
from chinou.util.access import SSOException, get_sso_token

###############################################################################
# Step 1: Load environment variables
###############################################################################
load_dotenv()

swarm_resource = "/chinou/data/llm-digital-office-general"
sso_token = None
try:
    sso_token = get_sso_token()
except SSOException:
    print(f"user access denied: please ensure user is added to SWARM group: {swarm_resource}")

# Model/endpoint settings
llm_endpoint = os.getenv("LLM_ENDPOINT", "http://chinou-api-stg.us-east-1.aws.nomura.com/invoke")
model = os.getenv("MODEL_NAME", "anthropic-3-haiku[Bedrock]")

temperature = float(os.getenv("MODEL_TEMPERATURE", 0.4))
top_k = int(os.getenv("MODEL_TOP_K", 40))
top_p = float(os.getenv("MODEL_TOP_P", 0.9))
max_new_tokens = int(os.getenv("MODEL_MAX_NEW_TOKENS", 2048))

# A comma-separated list of database names, e.g. "nss2, complianceportal"
DATABASES_STR = os.getenv("DATABASES", "nss2,complianceportal")
DATABASES = [db.strip() for db in DATABASES_STR.split(",") if db.strip()]

###############################################################################
# Step 2: Function to load or create a JSON file with DB details & schema
###############################################################################
def load_or_create_db_details_and_schema(db_name: str) -> dict:
    """
    1. Tries to read 'db/<db_name>_details.json' for existing credentials + schema.
    2. If not found (or missing schema), fetch credentials from environment,
       connect to DB, run get_table_info(), and store in the JSON.
       
    JSON structure (example):
    {
        "driver": "ODBC+Driver+17+for+SQL+Server",
        "server_name": "SQL00814",
        "user": "...",
        "password": "...",
        "port": "1433",
        "schema": "Raw schema text from db_obj.get_table_info()"
    }
    """

    # Ensure the 'db' folder exists
    os.makedirs("db", exist_ok=True)
    details_path = os.path.join("db", f"{db_name}_details.json")

    # If JSON exists, load it
    if os.path.exists(details_path):
        with open(details_path, "r", encoding="utf-8") as f:
            details = json.load(f)
        print(f"Loaded DB details for '{db_name}' from {details_path}.")

        # If "schema" is missing or empty, fetch from DB now
        if not details.get("schema"):
            print(f"No schema found in JSON for '{db_name}'. Fetching from DB...")
            new_schema = fetch_db_schema(details, db_name)
            details["schema"] = new_schema
            save_db_details(details_path, details)
            print(f"Updated JSON with schema for '{db_name}'.")
        return details

    # JSON file does not exist => read from environment, connect & fetch schema
    print(f"No JSON file found for '{db_name}'. Attempting to read env vars and create JSON...")

    db_name_upper = db_name.upper()
    driver = os.getenv("SQL_DRIVER", "ODBC+Driver+17+for+SQL+Server")
    server_name = os.getenv("SERVER_NAME", "SQL00814")
    user = os.getenv(f"SQL_USER_{db_name_upper}") or os.getenv("SQL_USER")
    password = os.getenv(f"SQL_PASSWORD_{db_name_upper}") or os.getenv("SQL_PASSWORD")
    port = os.getenv(f"SQL_PORT_{db_name_upper}") or os.getenv("SQL_PORT", "1433")

    if not user:
        raise ValueError(f"Error: No username found for {db_name}. Check env vars or create JSON manually.")
    if not password:
        raise ValueError(f"Error: No password found for {db_name}. Check env vars or create JSON manually.")

    # Create an in-memory dict
    details = {
        "driver": driver,
        "server_name": server_name,
        "user": user,
        "password": password,
        "port": port,
        "schema": ""  # placeholder
    }

    # Fetch raw schema from DB
    new_schema = fetch_db_schema(details, db_name)
    details["schema"] = new_schema

    # Save details to JSON for future runs
    save_db_details(details_path, details)
    print(f"Created new JSON with credentials & schema for '{db_name}': {details_path}")

    return details

def save_db_details(details_path: str, details: dict):
    """Helper to write the details dictionary to JSON on disk."""
    with open(details_path, "w", encoding="utf-8") as f:
        json.dump(details, f, indent=2)

###############################################################################
# Step 3: Helper to fetch DB schema from a dictionary of DB details
###############################################################################
def fetch_db_schema(details: dict, db_name: str) -> str:
    """Connects to the DB and fetches the raw schema text via get_table_info()."""
    from langchain.sql_database import SQLDatabase

    driver_encoded = details["driver"].replace(" ", "+")
    connection_str = (
        f"mssql+pyodbc://{details['user']}:{details['password']}"
        f"@{details['server_name']}:{details['port']}/{db_name}?"
        f"driver={driver_encoded}"
        f"&TrustServerCertificate=yes"
        f"&encrypt=yes"
        f"&timeout=30"
    )
    try:
        engine = create_engine(connection_str)
        db_obj = SQLDatabase(engine)
        raw_schema = db_obj.get_table_info()
        print(f"Fetched schema for '{db_name}'.")
        return raw_schema
    except Exception as e:
        print(f"Warning: Could not fetch schema for '{db_name}': {e}")
        return f"[Schema unavailable: {e}]"

###############################################################################
# Step 4: Build a list of Tools for SQL queries (optional)
###############################################################################
def make_sql_tools():
    """
    Creates a list of Tools (one per DB) for read-only SQL queries, pulling 
    credentials from <db_name>_details.json if it exists, otherwise from env vars.
    """
    from langchain.sql_database import SQLDatabase

    tools_list = []
    print("Attempting to create SQL tools...")

    if not DATABASES:
        raise ValueError("No databases specified in 'DATABASES' environment variable.")

    for db_name in DATABASES:
        details = load_or_create_db_details_and_schema(db_name)

        # Build the connection string from the JSON details
        driver_encoded = details["driver"].replace(" ", "+")
        connection_str = (
            f"mssql+pyodbc://{details['user']}:{details['password']}"
            f"@{details['server_name']}:{details['port']}/{db_name}?"
            f"driver={driver_encoded}"
            f"&TrustServerCertificate=yes"
            f"&encrypt=yes"
            f"&timeout=30"
        )

        try:
            engine = create_engine(connection_str)
            sql_db = SQLDatabase(engine)
            print(f"SQLDatabase object created for '{db_name}'.")
        except Exception as e:
            print(f"\n--- ERROR: Failed to create engine/SQLDatabase for '{db_name}' ---")
            safe_conn_str = connection_str.replace(details['password'], '***')
            print(f"Connection string used (pw hidden): {safe_conn_str}")
            print(f"Error: {e}\n")
            continue

        # The function that runs a query
        def run_query(query: str) -> str:
            print(f"\n--- Running Query on '{db_name}': ---\n{query}\n---------------------------------")
            try:
                result = sql_db.run(query)
                print(f"\n--- Result from {db_name}: ---\n{result}\n-------------------------------")
                return str(result)
            except Exception as ex:
                error_message = f"SQL error on {db_name}: {ex}"
                print(f"\n--- Error executing query on '{db_name}': ---\n{error_message}\n-----------------------------")
                return error_message

        # Create a LangChain Tool for this DB
        tool = Tool(
            name=f"Query_{db_name}",
            func=run_query,
            description=(
                f"Use this tool to execute a single SELECT on the '{db_name}' database.\n"
                f"Input must be a valid SQL query for SQL Server.\n"
                f"Only use if data is needed from '{db_name}'."
            ),
        )
        tools_list.append(tool)
        print(f"Successfully created tool: Query_{db_name}")

    if not tools_list:
        raise ValueError("No SQL tools could be created. Check DB configs.")
    print(f"Finished creating tools. {len(tools_list)} tools available.")
    return tools_list

###############################################################################
# Step 5: Create the LLM (ProxyLLM) for normal single-shot prompting
###############################################################################
def create_llm():
    """
    Creates the ProxyLLM object (Chinou) with the chosen model and hyperparameters.
    """
    print("Initializing Chinou LLM...")

    if "llama-2" in model.lower():
        model_params = {
            "temperature": temperature,
            "top_p": top_p,
            "max_tokens": max_new_tokens
        }
    elif "anthropic-3" in model.lower():
        model_params = {
            "temperature": temperature,
            "top_p": top_p,
            "top_k": top_k,
            "max_new_tokens": max_new_tokens
        }
    else:
        # Generic fallback
        model_params = {
            "temperature": temperature,
            "top_p": top_p,
            "top_k": top_k,
            "max_tokens": max_new_tokens
        }

    print(f"Model: {model}")
    print(f"Model params: {model_params}")

    llm_descriptor = LLMDescriptor(model=model, model_params=model_params)
    try:
        user_token = get_sso_token()
    except SSOException:
        user_token = None

    chinou_llm = ProxyLLM(url=llm_endpoint, user=user_token, model_descriptor=llm_descriptor)
    print("Chinou LLM initialized.")
    return chinou_llm

###############################################################################
# Step 6: Prepare a final function to gather the schema from JSON
###############################################################################
def get_schema_prompt():
    """
    Reads the "schema" for each DB from <db_name>_details.json (creating/fetching if needed)
    and compiles them into a single text block for your LLM prompt.
    """
    schema_lines = []
    print("\nGathering schema from JSON or DB as needed...")

    for db_name in DATABASES:
        details = load_or_create_db_details_and_schema(db_name)
        raw_schema = details.get("schema", "[No schema available]")
        schema_lines.append(f"### Database: {db_name}\nSchema:\n```sql\n{raw_schema}\n```\n")

    final_schema_text = "\n".join(schema_lines)
    print("Schema ready.")
    return final_schema_text

###############################################################################
# Step 7: Main Q&A loop with a normal single-shot prompt
###############################################################################
def main():
    try:
        # Build SQL Tools (optional if you want them for tool usage)
        sql_tools = make_sql_tools()
        
        # Create the LLM
        llm = create_llm()

        # Fetch schema from local JSON or DB as needed
        schema_context = get_schema_prompt()

        print("\nSystem setup complete. You can now ask questions:")
        print("==================================================")

        # Example snippet for your prompt
        EXAMPLE_DIALOGUE = """
[System]
You are a helpful assistant capable of answering user questions with SQL knowledge.
You can suggest queries or show summarized results as needed.

[Example #1]
User: "How many employees are in the HR table?"
Assistant: "There are 53 employees in the HR_Employees table."

[Example #2]
User: "What is the top product by sales?"
Assistant: "The top product by sales is 'Laptop Model X' with $1,200,000 in total sales."
---
"""

        while True:
            user_question = input("\nAsk a question (or type 'exit' to quit): ")
            if user_question.lower() in ["exit", "quit"]:
                print("Goodbye!")
                break
            if not user_question.strip():
                continue

            # Construct a single-shot prompt with system instructions, schema, examples, etc.
            full_prompt = f"""
[System]
You are an AI assistant that answers user questions clearly and succinctly.
Here are the database schemas you have access to (from JSON cache or fresh fetch):

{schema_context}

Use this context to help answer queries about the data. 
(Do not expose chain-of-thought explicitly.)

Here are some examples:
{EXAMPLE_DIALOGUE}

[User Question]
{user_question}

[Assistant's Response]:
"""

            print("\n--- LLM Prompt Start ---")
            print(full_prompt)
            print("--- LLM Prompt End ---\n")

            try:
                answer = llm.invoke(full_prompt)
                print(f"Assistant: {answer}\n")

            except Exception as e:
                print(f"\nError during LLM query: {e}")
                traceback.print_exc()

    except Exception as ex:
        print(f"Error in main: {ex}")
        traceback.print_exc()

if __name__ == "__main__":
    main()
